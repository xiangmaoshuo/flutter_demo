// 网上找到的配置博客 https://www.jianshu.com/p/c11862136abf
// https://www.cnblogs.com/travellife/p/Gradle-shi-xian-Android-duo-qu-dao-ding-zhi-hua-da.html, 这个比较全
// https://www.jianshu.com/p/ad423ed030b6

def localProperties = new Properties()
def localPropertiesFile = rootProject.file('local.properties')

if (localPropertiesFile.exists()) {
    localPropertiesFile.withReader('UTF-8') { reader ->
        localProperties.load(reader)
    }
}

def flutterRoot = localProperties.getProperty('flutter.sdk')
if (flutterRoot == null) {
    throw new GradleException("Flutter SDK not found. Define location with flutter.sdk in the local.properties file.")
}

def flutterVersionCode = localProperties.getProperty('flutter.versionCode')
if (flutterVersionCode == null) {
    flutterVersionCode = '1'
}

def flutterVersionName = localProperties.getProperty('flutter.versionName')
if (flutterVersionName == null) {
    flutterVersionName = '1.0'
}

// 声明是Android程序，
//com.android.application 表示这是一个应用程序模块
//com.android.library 标识这是一个库模块
//而这区别：前者可以直接运行，后着是依附别的应用程序运行

apply plugin: 'com.android.application'
apply from: "$flutterRoot/packages/flutter_tools/gradle/flutter.gradle"

def keystorePropertiesFile = rootProject.file("key.properties")
def keystoreProperties = new Properties()
keystoreProperties.load(new FileInputStream(keystorePropertiesFile))

def baseAppId = "com.example.flutter_demo"

static def releaseTime() {
    return new Date().format("yyyy-MM-dd", TimeZone.getTimeZone("UTC"))
}

android {
    compileSdkVersion 28

    lintOptions {
        disable 'InvalidPackage'
    }

    defaultConfig {
        applicationId "${baseAppId}"
        minSdkVersion 16
        targetSdkVersion 28
        versionCode flutterVersionCode.toInteger()
        versionName flutterVersionName
        testInstrumentationRunner "android.support.test.runner.AndroidJUnitRunner" // 表明要使用AndroidJUnitRunner进行单元测试。
        manifestPlaceholders = [ app_label :"苑歌", app_icon: "@mipmap/ic_launcher" ]
    }

    signingConfigs {
        release {
            keyAlias keystoreProperties['keyAlias']
            keyPassword keystoreProperties['keyPassword']
            storeFile file(keystoreProperties['storeFile'])
            storePassword keystoreProperties['storePassword']
        }
    }
    // 如果对于debug版本和release版本有不同的配置，可以考虑使用AndroidManifest.xml配置文件来配置
    // 也可以如下，直接修改对应文本
    buildTypes {
        release {
            // minifyEnabled true  // 是否压缩代码， 这个暂时不能开启，因为本项目引用了flutter_webview_plugin，在压缩时有报错，暂时处理不来，就先关闭
            useProguard true // 是否混淆代码
            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'// 指定混淆的规则文件
            signingConfig signingConfigs.release
            buildConfigField "boolean", "LOG_DEBUG", "false" // 这是是buildConfigField的用法，在这里可以配置一个字段（如LOG_DEBUG），然后在代码中使用BuildConfig.LOG_DEBUG
        }

        debug {
           applicationIdSuffix "debug"
           manifestPlaceholders = [ app_label :"苑歌_debug", app_icon: "@mipmap/ic_launcher_debug" ]
           buildConfigField "boolean", "LOG_DEBUG", "true"
        }
    }

    /*
        buildTypes：确定打包的模式，默认有debug和release模式
        productFlavors：是在buildTypes的基础上，我们需要对应多种场景，比如什么utc环境的release版本，test环境的release版本。
        productFlavors里面的配置会继承defaultConfig的配置
    */
    // productFlavors {
    //     // 线上环境
    //     xianshang {
    //         applicationId "${baseAppId}.release"
    //         manifestPlaceholders = [ app_label :"苑歌", app_icon: "@mipmap/ic_launcher" ]
    //         // buildConfigField 'String', 'BASE_URL', '"http://xxx.xxx.xxxx"' //正式环境下的网络请求基地址
    //         // resValue "string", "app_name", "XXX"//正式环境下app名称
    //     }
    //     // utc模式
    //     utc {
    //         applicationId "${baseAppId}.debug"
    //         manifestPlaceholders = [ app_label :"苑歌—debug", app_icon: "@mipmap/ic_launcher" ]
    //     }
    // }

    // 自定义打包名称， debug版本需要固定名称，原因可能是flutter默认去找的是app-debug.apk这个文件名，你改了名称后，他找不到要报错
    // release版本改名可以成功，但是控制台会报错:Gradle build failed to produce an Android package，原因同上，flutter默认找的是app-release.apk，
    // 目前可以忽略该错误，实际是打包成功了的，虽然有上面的小瑕疵，等以后再解决吧，目前使用没问题
    applicationVariants.all {
        variant ->
            variant.outputs.all {
                if (buildType.name == 'debug') {
                    outputFileName = 'app-debug.apk'
                } else {
                    outputFileName  = "yuang_ge_v${defaultConfig.versionName}_${buildType.name}_${releaseTime()}.apk"
                }
            }

    }
}

flutter {
    source '../..'
}

dependencies {
    testImplementation 'junit:junit:4.12'
    androidTestImplementation 'com.android.support.test:runner:1.0.2'
    androidTestImplementation 'com.android.support.test.espresso:espresso-core:3.0.2'
}
